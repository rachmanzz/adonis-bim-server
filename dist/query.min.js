const{isArray:isArray,iString:iString,isNotUndef:isNotUndef}=require("bimn");class Query{loadModel(t){this.model=t,this.oprator={sq:"<=",s:"<",bq:">=",b:">",n:"!="}}where(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._where(e)}}iString(t)&&this._where(t)}orwhere(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._orWhere(e)}}iString(t)&&this._orWhere(t)}_where(t){if(iString(t)){if(/^[\w\d]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d]+)$/);let i=e[1],r=e[2];this.model.where(i,r)}if(/^[\w\d]+\|[\w\d]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d]+)\|([\w\d]+)$/),i=e[1],r=e[2],s=e[3];isNotUndef(this.oprator[s])&&this.model.where(i,this.oprator[s],r)}if(/^[\w\d]+\|\![0-9]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|\!([0-9]+)$/);let i=e[1],r=parseInt(e[2]);this.model.where(i,r)}if(/^[\w\d]+\|\![0-9]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|\!([0-9]+)\|([\w\d]+)$/),i=e[1],r=parseInt(e[2]),s=e[3];isNotUndef(this.oprator[s])&&this.model.where(i,this.oprator[s],r)}}}_orWhere(t){if(iString(t)){if(/^[\w\d]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d]+)$/);let i=e[1],r=e[2];this.model.orWhere(i,r)}if(/^[\w\d]+\|[\w\d]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d]+)\|([\w\d]+)$/),i=e[1],r=e[2],s=e[3];isNotUndef(this.oprator[s])&&this.model.orWhere(i,this.oprator[s],r)}if(/^[\w\d]+\|\![0-9]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|\!([0-9]+)$/);let i=e[1],r=parseInt(e[2]);this.model.orWhere(i,r)}if(/^[\w\d]+\|\![0-9]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|\!([0-9]+)\|([\w\d]+)$/),i=e[1],r=parseInt(e[2]),s=e[3];isNotUndef(this.oprator[s])&&this.model.orWhere(i,this.oprator[s],r)}}}_between(t){if(/^[\w\d]+\|[0-9]+\-[0-9]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([0-9]+)\-([0-9]+)$/);let i=e[1],r=parseInt(e[2]),s=parseInt(e[3]);this.model.whereBetween(i,[r,s])}}_whereLike(t){if(/^[\w\d]+\|[\w\d\,_]+\|[\w\d]+$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d\,_]+)\|([\w\d]+)$/);let i=e[1],r=e[2],s=e[3];isNotUndef(s)&&this.model.whereRaw(i+" LIKE ?",[this._likeGen(s,r)])}}_likeGen(t,e){var i=e;switch(t){case"start_with":i=e+"%";break;case"end_with":i="%"+e;break;case"any_position":i="%"+e+"%";break;case"start_with_end":const s=/^[\w\d]+\,[\w\d]+$/.test(r=e)?r.split(","):r;i=isArray(s)?s[0]+"%"+s[0]:s;break;default:i=e}var r;return i}wherelike(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._whereLike(e)}}iString(t)&&this._whereLike(t)}between(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._between(e)}}iString(t)&&this._between(t)}groupby(t){this.model.groupBy(t)}offset(t){this.model.offset(parseInt(t))}limit(t){this.model.limit(parseInt(t))}_orderBy(t){if(/^[\w\d]+\|asc$|^[\w\d]+\|desc$/.test(t)){const e=t.match(/(^[\w\d]+)\|([\w\d]+)$/),i=e[1],r=e[2];this.model.orderBy(i,r)}}orderby(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._orderBy(e)}}iString(t)&&this._orderBy(t)}_with(t){this.model.with(t)}with(t){if(isArray(t)){const e=t.length;for(let i=0;i<e;i++){let e=t[i];this._with(e)}}iString(t)&&this._with(t)}}module.exports=Query;
